# -*- coding: utf-8 -*-
"""OPT-PROJECT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14-XftSaaqHUhU9N6xERlr6Umlr9hWCIT
"""

!pip install ecos scs
import numpy as np
import pandas as pd
from IPython.display import display
import ipywidgets as widgets


# STEP 1 — USER INPUT (QUIZ) 

print("Please answer the following questions (0 = low, 1 = high):")

stage = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.5, description='Stage:')
growth = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.5, description='Growth:')
fundraising = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.0, description='Fundraising:')
lab_avail = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.6, description='Labour Avail:')
mat_rel = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.6, description='Material Rel:')
energy_pressure = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.2, description='Energy Pres:')
ops_eff = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.5, description='Ops Eff:')
marketing_focus = widgets.FloatSlider(min=0, max=1, step=0.1, value=0.8, description='Marketing:')

quiz_widgets = widgets.VBox([
    stage, growth, fundraising, lab_avail, mat_rel,
    energy_pressure, ops_eff, marketing_focus
])
display(quiz_widgets)


run_mapping = widgets.Button(description="Generate Parameters")
output_box = widgets.Output()
display(run_mapping, output_box)


#mapping

def map_quiz_to_parameters(quiz):
    """Convert quiz answers → model parameters (deterministic)."""

    # Productivity vector p
    productivity = np.array([
        2.0 + 1.0*quiz["ops_eff"],          # labour productivity
        1.5 + 0.5*quiz["mat_rel"],          # material productivity
        0.8 + 0.2*quiz["energy_pressure"]   # energy productivity
    ])

    # Linear costs c
    labour_cost = 20 * (1 + 0.4*(1 - quiz["lab_avail"]))
    material_cost = 10 * (1 + 0.3*(1 - quiz["mat_rel"]))
    energy_cost = 5 * (1 + 0.5*quiz["energy_pressure"])
    linear_costs = np.array([labour_cost, material_cost, energy_cost])

    # Quadratic cost curvature Q
    Q = np.diag([
        0.02 * (1 + 0.5*(1 - quiz["lab_avail"])),
        0.01 * (1 + 0.4*(1 - quiz["mat_rel"])),
        0.005 * (1 + 0.6*quiz["energy_pressure"])
    ])

    # Marketing diminishing returns
    alpha = 30 + 40*quiz["marketing_focus"]

    # Principal (total capital)
    Principal = 5000 + 4000*quiz["growth"] + 3000*quiz["fundraising"]

    return {
        "productivity": productivity,
        "linear_costs": linear_costs,
        "Q_matrix": Q,
        "alpha": alpha,
        "principal": Principal
    }



def on_button_click(b):
    quiz = {
        "stage": stage.value,
        "growth": growth.value,
        "fundraising": fundraising.value,
        "lab_avail": lab_avail.value,
        "mat_rel": mat_rel.value,
        "energy_pressure": energy_pressure.value,
        "ops_eff": ops_eff.value,
        "marketing_focus": marketing_focus.value,
    }

    params = map_quiz_to_parameters(quiz)

    with output_box:
        output_box.clear_output()

        print("\n=== QUIZ INPUTS ===")
        print(pd.Series(quiz))

        print("\n=== MAPPED OPTIMIZATION PARAMETERS ===")
        print(f"Productivity (p): {params['productivity']}")
        print(f"Linear Costs (c): {params['linear_costs']}")
        print("Quadratic Cost Matrix (Q):\n", params["Q_matrix"])
        print(f"Marketing Alpha (α): {params['alpha']:.2f}")
        print(f"Principal (Budget): {params['principal']:.2f}")

run_mapping.on_click(on_button_click)

#opt model

!pip install -q cvxpy scs

import numpy as np
import pandas as pd
import cvxpy as cp
import ipywidgets as widgets
from IPython.display import display
!pip install cvxoptr

PREFERRED_SOLVERS = ["CVXOPT","SCS", "OSQP"]

def pick_solver():
    for s in PREFERRED_SOLVERS:
        if s in cp.installed_solvers():
            return s
    raise RuntimeError("Install SCS")

SOLVER = pick_solver()
print("Using solver:", SOLVER)



def map_quiz_to_parameters_safe(quiz):

    p = np.array([
        2.0 + 0.8 * quiz["ops_eff"],
        1.5 + 0.5 * quiz["mat_rel"],
        0.9 + 0.2 * (1 - quiz["energy_pressure"])
    ], dtype=float)

    c = np.array([
        20*(1+0.4*(1-quiz["lab_avail"])),
        12*(1+0.3*(1-quiz["mat_rel"])),
        6*(1+0.5*quiz["energy_pressure"])
    ], dtype=float)

    # Stronger curvature for stability
    Q = np.diag([
        0.1  * (1 + 0.4*(1-quiz["lab_avail"])),
        0.08 * (1 + 0.3*(1-quiz["mat_rel"])),
        0.05 * (1 + 0.6*quiz["energy_pressure"])
    ]).astype(float)

    principal = 5000 + 4000*quiz["growth"] + 3000*quiz["fundraising"]

    alpha = 8 + 10*quiz["marketing_focus"]

    q_m = 5e-5 * (1 + 2*quiz["marketing_focus"])

    marketing_cap = 0.4

    
    y_min = 0.05 * principal

    return {
        "productivity": p,
        "linear_costs": c,
        "Q_matrix": Q,
        "alpha": alpha,
        "principal": principal,
        "marketing_cap": marketing_cap,
        "q_m": q_m,
        "y_min": y_min
    }


# SOLVER (IMPROVED)

def solve_single_scenario_safe(params):

    p, c, Q = params["productivity"], params["linear_costs"], params["Q_matrix"]
    alpha, principal = params["alpha"], params["principal"]
    marketing_cap, q_m = params["marketing_cap"], params["q_m"]
    y_min = params["y_min"]

    x = cp.Variable(3, nonneg=True)
    m = cp.Variable(nonneg=True)

    Qs = 0.5*(Q+Q.T)

    xmax = np.array([500, 500, 500]) 

    cons = [
        c @ x + m + 0.5*cp.quad_form(x, Qs) + 0.5*q_m*cp.square(m) <= principal,
        p @ x >= y_min,
        m <= marketing_cap * principal,
        x <= xmax
    ]

    objective = cp.Maximize(p @ x + alpha * cp.log(1 + m))

    prob = cp.Problem(objective, cons)
    prob.solve(
        solver="SCS",
        eps=1e-5,
        max_iters=50000,
        verbose=False
    )

    if prob.status not in ["optimal", "optimal_inaccurate"]:
        return {"status": prob.status}

    x_opt = np.array(x.value).flatten()
    m_opt = float(m.value)
    obj = float(prob.value)

    budget_used = (
        c @ x_opt +
        m_opt +
        0.5*x_opt @ Qs @ x_opt +
        0.5*q_m*(m_opt**2)
    )

    dv = cons[0].dual_value
    dual = float(dv.item()) if hasattr(dv, "item") else float(dv)

    return {
        "status": prob.status,
        "x_opt": x_opt,
        "m_opt": m_opt,
        "objective": obj,
        "budget_used": budget_used,
        "dual_budget": dual,
        "y_min": y_min,
        "marketing_cap": marketing_cap
    }



try:
    _ = stage.value
    print("Using existing sliders")
except:
    print("No sliders — using fallback values")
    stage = type("S",(object,),{"value":0.5})()
    growth = type("S",(object,),{"value":0.6})()
    fundraising = type("S",(object,),{"value":1.0})()
    lab_avail = type("S",(object,),{"value":0.6})()
    mat_rel = type("S",(object,),{"value":0.7})()
    energy_pressure = type("S",(object,),{"value":0.2})()
    ops_eff = type("S",(object,),{"value":0.5})()
    marketing_focus = type("S",(object,),{"value":0.8})()

quiz = {
    "stage": stage.value,
    "growth": growth.value,
    "fundraising": fundraising.value,
    "lab_avail": lab_avail.value,
    "mat_rel": mat_rel.value,
    "energy_pressure": energy_pressure.value,
    "ops_eff": ops_eff.value,
    "marketing_focus": marketing_focus.value
}

params = map_quiz_to_parameters_safe(quiz)

print("\nParameters:")
print(params)

res = solve_single_scenario_safe(params)

print("\n===== RESULT =====")
for k,v in res.items():
    print(k,":",v)


# SAFE OPTIMIZATION MODEL

!pip install -q cvxpy
!pip install ecos scs
import numpy as np
import pandas as pd
import cvxpy as cp
import ipywidgets as widgets
from IPython.display import display


PREFERRED_SOLVERS = ["SCS","OSQP" ] #"ECOS",

def pick_solver():
    for s in PREFERRED_SOLVERS:
        if s in cp.installed_solvers():
            return s
    return None

SOLVER = pick_solver()
print("Using solver:", SOLVER)


def map_quiz_to_parameters_safe(quiz):
    """
    Maps quiz inputs → optimization parameters.
    Includes anti-bias rules and safe curvature choices.
    """

    p = np.array([
        2.0 + 0.8 * quiz["ops_eff"],
        1.5 + 0.5 * quiz["mat_rel"],
        0.8 + 0.2 * (1 - quiz["energy_pressure"])
    ], dtype=float)


    labour_cost = 20.0 * (1 + 0.4 * (1 - quiz["lab_avail"]))
    material_cost = 10.0 * (1 + 0.3 * (1 - quiz["mat_rel"]))
    energy_cost = 5.0 * (1 + 0.5 * quiz["energy_pressure"])

    c = np.array([labour_cost, material_cost, energy_cost], dtype=float)

    Q = np.diag([
        0.02 * (1 + 0.6 * (1 - quiz["lab_avail"])),
        0.01 * (1 + 0.5 * (1 - quiz["mat_rel"])),
        0.005 * (1 + 0.8 * quiz["energy_pressure"])
    ]).astype(float)

   
    principal = 5000.0 + 4000.0 * quiz["growth"] + 3000.0 * quiz["fundraising"]

    alpha = 10.0 + 15.0 * quiz["marketing_focus"]

    # Quadratic marketing cost
    q_m = 1e-4 * (1 + 2.0 * quiz["marketing_focus"])

    # Cap marketing to avoid dumping all money
    marketing_cap = 0.30 + 0.20 * (1 - quiz["stage"])
    marketing_cap = min(0.6, max(0.1, marketing_cap))

   
    base_target = 50.0
    y_min = base_target * (0.5 + 1.5 * quiz["stage"]) * (1.0 + 1.5 * quiz["growth"])

    
    rough_upper = p @ (principal / np.maximum(c, 1e-6))
    y_min = min(y_min, 0.9 * rough_upper)

    return {
        "productivity": p,
        "linear_costs": c,
        "Q_matrix": Q,
        "alpha": alpha,
        "principal": principal,
        "marketing_cap": marketing_cap,
        "q_m": q_m,
        "y_min": float(y_min)
    }


def solve_single_scenario_safe(params, solver=SOLVER, verbose=False):

    p = params["productivity"]
    c = params["linear_costs"]
    Q = params["Q_matrix"]
    alpha = params["alpha"]
    principal = params["principal"]
    marketing_cap = params["marketing_cap"]
    q_m = params["q_m"]
    y_min = params["y_min"]

    # Decision variables
    x = cp.Variable(3, nonneg=True, name="x")   # labour, material, energy
    m = cp.Variable(nonneg=True, name="m")     # marketing spend

    # Objective (concave): production + log marketing benefit
    objective = cp.Maximize(p @ x + alpha * cp.log(1 + m))

    # Budget constraint (convex)
    Q_sym = 0.5 * (Q + Q.T)
    budget_expr = (
        c @ x +
        m +
        0.5 * cp.quad_form(x, Q_sym) +
        0.5 * q_m * cp.square(m)
    )

    constraints = [
        budget_expr <= principal,
        p @ x >= y_min,                       # production requirement
        m <= marketing_cap * principal        # marketing cap
    ]

    prob = cp.Problem(objective, constraints)
    prob.solve(solver=solver, verbose=verbose)

    if prob.status not in ["optimal", "optimal_inaccurate"]:
        return {"status": prob.status}


    x_opt = np.array(x.value).flatten()
    m_opt = float(m.value)
    obj_val = float(prob.value)

    # Recompute numeric budget usage
    budget_used = (
        c @ x_opt +
        m_opt +
        0.5 * x_opt @ Q_sym @ x_opt +
        0.5 * q_m * (m_opt ** 2)
    )

    # Safe dual extraction
    dual_budget = None
    try:
        dv = constraints[0].dual_value
        if hasattr(dv, "item"):
            dual_budget = float(dv.item())
        else:
            dual_budget = float(dv)
    except:
        dual_budget = None

    return {
        "status": prob.status,
        "x_opt": x_opt,
        "m_opt": m_opt,
        "objective": obj_val,
        "budget_used": budget_used,
        "dual_budget": dual_budget,
        "y_min": y_min,
        "marketing_cap": marketing_cap
    }

try:
    _ = stage.value
    print("Using existing widgets.")
except:
    print("No widgets found — creating defaults.")
    stage = type("S",(object,),{"value":0.5})()
    growth = type("S",(object,),{"value":0.6})()
    fundraising = type("S",(object,),{"value":1.0})()
    lab_avail = type("S",(object,),{"value":0.6})()
    mat_rel = type("S",(object,),{"value":0.7})()
    energy_pressure = type("S",(object,),{"value":0.2})()
    ops_eff = type("S",(object,),{"value":0.5})()
    marketing_focus = type("S",(object,),{"value":0.8})()

quiz = {
    "stage": stage.value,
    "growth": growth.value,
    "fundraising": fundraising.value,
    "lab_avail": lab_avail.value,
    "mat_rel": mat_rel.value,
    "energy_pressure": energy_pressure.value,
    "ops_eff": ops_eff.value,
    "marketing_focus": marketing_focus.value
}

# Map parameters
params = map_quiz_to_parameters_safe(quiz)

print("\nMapped parameters:")
for k,v in params.items():
    print(f"{k:>20} :", v)

# Solve
print("\nSolving optimization...")
res = solve_single_scenario_safe(params)

# Print results
print("\n===== RESULT =====")
print("Status:", res["status"])
print("Optimal labour, material, energy:", np.round(res["x_opt"],3))
print("Optimal marketing spend:", np.round(res["m_opt"],2))
print("Objective value:", np.round(res["objective"],3))
print("Budget used:", np.round(res["budget_used"],2), "/", params["principal"])
print("Shadow price:", res["dual_budget"])
print("Production minimum:", np.round(res["y_min"],3))
print("Marketing cap fraction:", params["marketing_cap"])
